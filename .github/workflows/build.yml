name: Build and Package

on:
  pull_request:
    types: [opened, reopened]
    branches: [ main ]
    paths:
      - 'LibraryA/**'
      - 'LibraryB/**'
      - 'LibraryC/**'
      - 'LibraryD/**'

permissions:
  contents: write
  pull-requests: write
  packages: write

jobs:
  detect-and-build:
    # Check if the branch name matches Release.#.#.#
    if: startsWith(github.head_ref, 'Release.')
    runs-on: windows-latest
    env:
      DOTNET_VERSION: '8.0.x'
      GITHUB_PACKAGES_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
      NUGET_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CONFIGURATION: Release
      PR_BRANCH: ${{ github.head_ref }}
      GIT_USER_EMAIL: "action@github.com"
      GIT_USER_NAME: "GitHub Action"
      OUTPUT_DIR: ./nupkg

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ env.PR_BRANCH }}
        clean: true

    - name: Validate Branch Name
      shell: bash
      id: validate
      run: |
        if ! [[ ${{ env.PR_BRANCH }} =~ ^Release\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Branch name must follow format Release.#.#.#"
          exit 1
        fi

    - name: Detect Changed Packages
      id: filter
      uses: dorny/paths-filter@v3
      with:
        filters: |
          "A:LibraryA/LibraryA.csproj:B+C":
            - 'LibraryA/**'
          "B:LibraryB/LibraryB.csproj:C":
            - 'LibraryB/**'
          "C:LibraryC/LibraryC.csproj:":
            - 'LibraryC/**'
          "D:LibraryD/LibraryD.nuspec:":
            - 'LibraryD/**'

    - name: Order Dependencies
      shell: bash
      id: order
      run: |
        python3 - << 'EOF'
        import json
        import sys
        import os
        from collections import defaultdict

        def create_graph(items):
            graph = defaultdict(list)
            nodes = set()
            
            # Parse the items and build the graph
            for item in items:
                parts = item.strip('"').split(':')
                key = parts[0]
                deps = parts[2].split('+') if parts[2] else []
                nodes.add(key)
                for dep in deps:
                    if dep:
                        graph[key].append(dep)
                        nodes.add(dep)
            return graph, nodes

        def topological_sort(graph, nodes):
            # Track visited nodes and detect cycles
            visited = set()
            temp = set()
            order = []
            
            def visit(node):
                if node in temp:
                    sys.exit(f"Error: Circular dependency detected involving {node}")
                if node not in visited:
                    temp.add(node)
                    for dep in graph[node]:
                        visit(dep)
                    temp.remove(node)
                    visited.add(node)
                    order.append(node)
            
            # Visit each node
            for node in nodes:
                if node not in visited:
                    visit(node)
            
            return order

        # Get the changes from GitHub Actions environment
        changes = '${{ steps.filter.outputs.changes }}'
        if changes == '[]':
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write('ordered_changes=[]')
            sys.exit(0)

        # Remove brackets and split into items
        items = [item.strip() for item in changes.strip('[]').split(',')]
        
        # Create dependency graph
        graph, nodes = create_graph(items)
        
        # Get topological order
        ordered_keys = topological_sort(graph, nodes)
        
        # Filter and reorder the original items based on the topological order
        ordered_items = []
        key_to_item = {item.strip('"').split(':')[0]: item for item in items}
        for key in ordered_keys:
            if key in key_to_item:
                ordered_items.append(key_to_item[key])
        
        # Output the ordered array using environment file
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'ordered_changes=[{",".join(ordered_items)}]')
        EOF

    - name: Get PR Comments
      id: pr_comment
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });
          const prBody = context.payload.pull_request.body || '';
          const allText = [prBody, ...comments.map(c => c.body)].join('\n');
          return allText;
        result-encoding: string

    - name: Update Versions
      shell: bash
      id: versions
      run: |
        python3 - << 'EOF'
        import xml.etree.ElementTree as ET
        import re
        import sys
        import os
        import glob

        # Register the namespace to avoid ns0 prefix
        ET.register_namespace('', 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd')

        def parse_version(version_str):
            match = re.match(r'(\d+)\.(\d+)\.(\d+)', version_str)
            if not match:
                return (0, 0, 0)
            return tuple(map(int, match.groups()))

        def get_version_from_file(file_path):
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                version_elem = tree.find(".//Version")
                return version_elem.text if version_elem is not None else "1.0.0"
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                version_elem = tree.find(".//ns:version", ns)
                return version_elem.text if version_elem is not None else "1.0.0"
            return "1.0.0"

        def update_version_in_file(file_path, new_version):
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                version_elem = tree.find(".//Version")
                if version_elem is not None:
                    version_elem.text = new_version
                tree.write(file_path, encoding='utf-8', xml_declaration=True)
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                version_elem = tree.find(".//ns:version", ns)
                if version_elem is not None:
                    version_elem.text = new_version
                # Use default namespace for writing
                tree.write(file_path, encoding='utf-8', xml_declaration=True)

        def update_dependency_version(file_path, dep_key, new_version):
            updated = False
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                # Look for PackageReference with the matching Include attribute
                for pkg_ref in tree.findall(".//PackageReference[@Include='Library{}']".format(dep_key)):
                    pkg_ref.set('Version', new_version)
                    updated = True
                if updated:
                    tree.write(file_path, encoding='utf-8', xml_declaration=True)
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                # Look for dependency with matching id
                for dep in tree.findall(".//ns:dependency[@id='Library{}']".format(dep_key), ns):
                    dep.set('version', new_version)
                    updated = True
                if updated:
                    tree.write(file_path, encoding='utf-8', xml_declaration=True)
            return updated

        def get_library_info(file_path):
            """Extract library name and its dependencies from a file."""
            deps = []
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                # Get package references
                for ref in tree.findall(".//PackageReference"):
                    pkg_name = ref.get('Include', '')
                    if pkg_name.startswith('Library'):
                        deps.append(pkg_name.replace('Library', ''))
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                # Get dependencies
                for dep in tree.findall(".//ns:dependency", ns):
                    dep_id = dep.get('id', '')
                    if dep_id.startswith('Library'):
                        deps.append(dep_id.replace('Library', ''))
            
            # Extract library name from path
            lib_name = os.path.basename(os.path.dirname(file_path)).replace('Library', '')
            return lib_name, deps

        def scan_all_libraries():
            """Scan workspace for all libraries and their dependencies."""
            library_info = {}
            
            # Find all .csproj and .nuspec files
            for pattern in ['*/*.csproj', '*/*.nuspec']:
                for file_path in glob.glob(pattern):
                    lib_name, deps = get_library_info(file_path)
                    if lib_name:
                        if lib_name not in library_info:
                            library_info[lib_name] = {'file_path': file_path, 'dependencies': set()}
                        library_info[lib_name]['dependencies'].update(deps)
            
            return library_info

        def calculate_new_version(current_version, key, pr_comments):
            major, minor, patch = parse_version(current_version)
            
            # Check for version change indicators in PR comments
            if f'[BREAKING_CHANGE:{key}]' in pr_comments:
                return f"{major + 1}.0.0"
            elif f'[NEW_FEATURE:{key}]' in pr_comments:
                return f"{major}.{minor + 1}.0"
            else:
                return f"{major}.{minor}.{patch + 1}"

        # Process the changes
        changes = '${{ steps.order.outputs.ordered_changes }}'
        pr_comments = '''${{ steps.pr_comment.outputs.result }}'''

        if changes == '[]':
            sys.exit(0)

        # Remove brackets and split into items
        items = [item.strip() for item in changes.strip('[]').split(',')]
        
        # First pass: Calculate all new versions for changed libraries
        version_updates = {}
        for item in items:
            parts = item.strip('"').split(':')
            key = parts[0]
            file_path = parts[1]
            
            # Get current version
            current_version = get_version_from_file(file_path)
            
            # Calculate new version
            new_version = calculate_new_version(current_version, key, pr_comments)
            
            # Store for later use
            version_updates[key] = {
                'file_path': file_path,
                'new_version': new_version,
                'current_version': current_version
            }

        # Scan all libraries in the workspace
        all_libraries = scan_all_libraries()

        # Second pass: Update versions and dependencies
        version_changes = []
        
        # First update the versions of changed libraries
        for key, info in version_updates.items():
            # Update the package's own version
            update_version_in_file(info['file_path'], info['new_version'])
            version_changes.append(f"{key}: {info['current_version']} -> {info['new_version']}")
            
            # Update this package's version in ALL libraries that depend on it
            for lib_key, lib_info in all_libraries.items():
                if key in lib_info['dependencies']:
                    if update_dependency_version(lib_info['file_path'], key, info['new_version']):
                        version_changes.append(f"{lib_key}: Updated dependency {key} to {info['new_version']}")

        # Print summary
        print("Version changes summary:")
        for change in version_changes:
            print(change)
        
        # Write output to environment file
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'version_changes={";".join(version_changes)}')
        EOF

    - name: Commit Version Updates
      if: steps.versions.outputs.version_changes != ''
      shell: bash
      run: |
        # Configure Git
        git config --local user.email "${{ env.GIT_USER_EMAIL }}"
        git config --local user.name "${{ env.GIT_USER_NAME }}"
        
        # Make sure the working directory is clean
        git clean -fd
        
        # Add and commit changes
        git add -A
        git status
        
        # Try to commit, with error handling
        if ! git commit -m "Update versions based on PR analysis [skip ci]"; then
          echo "No changes to commit or commit failed"
          exit 0
        fi
        
        # Try to push, with retries
        max_attempts=3
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          echo "Push attempt $attempt of $max_attempts"
          if git push; then
            echo "Push successful"
            break
          else
            echo "Push failed, cleaning and retrying..."
            git clean -fd
            git reset --hard HEAD
            git pull --rebase
            ((attempt++))
            if [ $attempt -gt $max_attempts ]; then
              echo "Failed to push after $max_attempts attempts"
              exit 1
            fi
            sleep 5
          fi
        done

    - name: Add PR Comment
      if: steps.versions.outputs.version_changes != ''
      uses: actions/github-script@v7
      with:
        script: |
          const changes = '${{ steps.versions.outputs.version_changes }}'.split(';');
          const body = `## Version Updates\nThe following version changes have been applied:\n\n${changes.map(c => `- ${c}`).join('\n')}`;
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: body
          });


    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        source-url: ${{ env.GITHUB_PACKAGES_URL }}

    - name: Configure NuGet Source
      shell: pwsh
      run: |
        Write-Host "=== Before removing sources ==="
        dotnet nuget list source
        
        # List and remove all existing GitHub sources
        $sources = dotnet nuget list source
        $sources | Where-Object { $_ -match "Github.*" } | ForEach-Object {
            $sourceName = $_.Trim()
            Write-Host "Removing source: $sourceName"
            dotnet nuget remove source $sourceName
        }
        
        Write-Host "=== After removing sources ==="
        dotnet nuget list source
        
        # Add the new source
        Write-Host "Adding new source..."
        dotnet nuget add source "${{ env.GITHUB_PACKAGES_URL }}" `
          --username "${{ github.repository_owner }}" `
          --password "${{ secrets.GITHUB_TOKEN }}" `
          --store-password-in-clear-text
        
        Write-Host "=== Final source configuration ==="
        dotnet nuget list source

    - name: Build and Pack NuGet Packages
      shell: bash
      run: |
        # Process ordered changes
        changes="${{ steps.order.outputs.ordered_changes }}"
        if [ "$changes" = "[]" ]; then
          echo "No libraries to build and pack"
          exit 0
        fi

        # Create nupkg directory
        mkdir -p ${{ env.OUTPUT_DIR }}

        # Remove outer brackets and quotes, and process each item in order
        echo "$changes" | sed 's/^\[\|\]$//g' | sed 's/"//g' | tr ',' '\n' | while read -r item; do
          # Trim whitespace
          item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if [ ! -z "$item" ]; then
            # Extract path
            path=$(echo "$item" | cut -d':' -f2)
            echo "Processing $path"

            if [[ $path == *.csproj ]]; then
              echo "Building and packing $path"
              dotnet build "$path" -c ${{ env.CONFIGURATION }} -p:UseNuGetReferences=true
              dotnet pack "$path" -c ${{ env.CONFIGURATION }} --no-build -o ${{ env.OUTPUT_DIR }}
              
              # Get the package name from the most recently created package
              pkg=$(ls -t ${{ env.OUTPUT_DIR }}/*.nupkg | head -n1)
              if [ -f "$pkg" ]; then
                echo "Publishing $pkg to ${{ env.GITHUB_PACKAGES_URL }}"
                dotnet nuget push "$pkg" \
                  --api-key "${{ secrets.GITHUB_TOKEN }}" \
                  --source "${{ env.GITHUB_PACKAGES_URL }}" \
                  --skip-duplicate \
                  --no-symbols
              fi
            elif [[ $path == *.nuspec ]]; then
              echo "Building and packing $path"
              # Get directory containing .nuspec file
              dir=$(dirname "$path")
              # Build the corresponding .csproj if it exists
              if [ -f "$dir/$dir.csproj" ]; then
                dotnet build "$dir/$dir.csproj" -c ${{ env.CONFIGURATION }}
              fi
              nuget pack "$path" -OutputDirectory ${{ env.OUTPUT_DIR }}
              
              # Get the package name from the most recently created package
              pkg=$(ls -t ${{ env.OUTPUT_DIR }}/*.nupkg | head -n1)
              if [ -f "$pkg" ]; then
                echo "Publishing $pkg to ${{ env.GITHUB_PACKAGES_URL }}"
                dotnet nuget push "$pkg" \
                  --api-key "${{ secrets.GITHUB_TOKEN }}" \
                  --source "${{ env.GITHUB_PACKAGES_URL }}" \
                  --skip-duplicate \
                  --no-symbols
              fi
            fi
          fi
        done

    - name: Create Git Tags
      if: steps.versions.outputs.version_changes != ''
      shell: bash
      run: |
        # Configure Git
        git config --local user.email "${{ env.GIT_USER_EMAIL }}"
        git config --local user.name "${{ env.GIT_USER_NAME }}"
        
        # Clean state before creating tags
        git clean -fd
        git reset --hard HEAD

        # Create a temporary file to store processed tags
        processed_tags=$(mktemp)

        # First create the release tag
        release_tag="${{ env.PR_BRANCH }}"
        echo "Creating release tag $release_tag"
        # Check if release tag already exists
        if git rev-parse "$release_tag" >/dev/null 2>&1; then
          echo "Release tag $release_tag already exists, skipping..."
        else
          # Try to create and push release tag with retries
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Release tag push attempt $attempt of $max_attempts"
            if git tag -a "$release_tag" -m "Release $release_tag" && git push origin "$release_tag"; then
              echo "Release tag push successful"
              break
            else
              echo "Release tag push failed, cleaning and retrying..."
              git tag -d "$release_tag" 2>/dev/null || true
              git fetch --tags
              ((attempt++))
              if [ $attempt -gt $max_attempts ]; then
                echo "Failed to push release tag after $max_attempts attempts"
                rm -f "$processed_tags"
                exit 1
              fi
              sleep 5
            fi
          done
        fi

        # Process each version change
        echo '${{ steps.versions.outputs.version_changes }}' | tr ';' '\n' | sort -u | while read -r change; do
          # Skip empty lines
          [ -z "$change" ] && continue
          
          # Extract library and version using grep instead of bash regex
          library=$(echo "$change" | grep -o '^[A-Z]')
          new_version=$(echo "$change" | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+$')
          
          if [ ! -z "$library" ] && [ ! -z "$new_version" ]; then
            tag_name="Library${library}/v${new_version}"
            
            # Check if we've already processed this tag
            if ! grep -q "^${tag_name}$" "$processed_tags"; then
              echo "$tag_name" >> "$processed_tags"
              
              echo "Creating tag $tag_name"
              # Check if tag already exists
              if git rev-parse "$tag_name" >/dev/null 2>&1; then
                echo "Tag $tag_name already exists, skipping..."
                continue
              fi
              
              # Try to create and push tag with retries
              max_attempts=3
              attempt=1
              while [ $attempt -le $max_attempts ]; do
                echo "Tag push attempt $attempt of $max_attempts"
                if git tag -a "$tag_name" -m "Release Library${library} version ${new_version}" && git push origin "$tag_name"; then
                  echo "Tag push successful"
                  break
                else
                  echo "Tag push failed, cleaning and retrying..."
                  git tag -d "$tag_name" 2>/dev/null || true
                  git fetch --tags
                  ((attempt++))
                  if [ $attempt -gt $max_attempts ]; then
                    echo "Failed to push tag after $max_attempts attempts"
                    rm -f "$processed_tags"
                    exit 1
                  fi
                  sleep 5
                fi
              done
            else
              echo "Tag $tag_name was already processed in this run, skipping..."
            fi
          else
            echo "Could not parse version change: $change"
            echo "Library: $library"
            echo "New version: $new_version"
          fi
        done

        # Clean up temporary file
        rm -f "$processed_tags"

    - name: Print Changed Libraries
      id: print_changes
      shell: bash
      run: |
        # Create a temporary file to store the output
        output_file=$(mktemp)
        
        changes="${{ steps.order.outputs.ordered_changes }}"
        if [ "$changes" = "[]" ]; then
          echo "No libraries were changed" | tee "$output_file"
        else
          {
            echo "# Changes Summary"
            echo ""
            echo "## Changed Libraries"
            # Remove outer brackets and quotes
            filtered_changes=$(echo "$changes" | sed 's/^\[\|\]$//g' | sed 's/"//g')
            
            # Process each item
            echo "$filtered_changes" | tr ',' '\n' | while read -r item; do
              # Trim leading/trailing whitespace
              item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              if [ ! -z "$item" ]; then
                # Extract each part using exact positions
                key=$(echo "$item" | cut -d':' -f1)
                path=$(echo "$item" | cut -d':' -f2)
                deps=$(echo "$item" | cut -d':' -f3)
                # Extract file extension without the dot
                ext=$(echo "$path" | grep -o '\.[^.]*$' | sed 's/\.//' || echo "no extension")
                # Only output if we have a valid key
                if [ ! -z "$key" ]; then
                  echo "* Library $key"
                  echo "  * Path: \\\`$path\\\`"
                  echo "  * Dependencies: ${deps:-none}"
                  echo "  * File type: $ext"
                  echo ""
                fi
              fi
            done

            echo "## Version Changes"
            if [ ! -z "${{ steps.versions.outputs.version_changes }}" ]; then
              echo "${{ steps.versions.outputs.version_changes }}" | tr ';' '\n' | while read -r change; do
                if [ ! -z "$change" ]; then
                  echo "* $change"
                fi
              done
            else
              echo "No version changes detected"
            fi

            echo ""
            echo "## Created Tags"
            # List the release tag first
            echo "* \\\`${{ env.PR_BRANCH }}\\\`"
            # List library tags
            if [ ! -z "${{ steps.versions.outputs.version_changes }}" ]; then
              echo "${{ steps.versions.outputs.version_changes }}" | tr ';' '\n' | sort -u | while read -r change; do
                if [ ! -z "$change" ]; then
                  library=$(echo "$change" | grep -o '^[A-Z]')
                  new_version=$(echo "$change" | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+$')
                  if [ ! -z "$library" ] && [ ! -z "$new_version" ]; then
                    echo "* \\\`Library${library}/v${new_version}\\\`"
                  fi
                fi
              done
            fi
          } | tee "$output_file"
        fi

        # Store the output as a step output (escape newlines for GitHub Actions)
        output_content=$(cat "$output_file")
        echo "summary<<EOF" >> $GITHUB_OUTPUT
        echo "$output_content" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Clean up
        rm -f "$output_file"

    - name: Add Changes Summary Comment
      if: steps.order.outputs.ordered_changes != '[]'
      uses: actions/github-script@v7
      with:
        script: |
          const summary = `${{ steps.print_changes.outputs.summary }}`
            .replace(/\\\`/g, '`'); // Convert escaped backticks back to regular backticks
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: summary
          });  