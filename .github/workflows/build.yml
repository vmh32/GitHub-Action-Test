name: Build and Package

on:
  pull_request:
    types: [opened, reopened]
    branches: [ main ]

jobs:
  detect-and-build:
    # Check if the branch name matches Release.#.#.#
    if: startsWith(github.head_ref, 'Release.')
    runs-on: windows-latest
    permissions:
      contents: write
      pull-requests: write
      packages: write
    env:
      DOTNET_VERSION: '8.0.x'
      GITHUB_APP_ID: ${{ secrets.ACTION_TEST_APP_ID }}
      GITHUB_APP_PRIVATE_KEY: ${{ secrets.ACTION_TEST_APP_PRIVATE_KEY }}
      GITHUB_APP_INSTALLATION_ID: ${{ secrets.ACTION_TEST_APP_INSTALLATION_ID }}
      GITHUB_PACKAGES_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
      CONFIGURATION: Release
      PR_BRANCH: ${{ github.head_ref }}
      GIT_USER_EMAIL: "action@github.com"
      GIT_USER_NAME: "GitHub Action"
      OUTPUT_DIR: ./nupkg

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ env.PR_BRANCH }}
        clean: true
        force: true

    - name: Clean Git State
      shell: bash
      run: |
        # Force clean any leftover files
        git clean -fdx
        # Reset any pending changes
        git reset --hard HEAD
        # Make sure the working directory is clean
        git status

    - name: Validate Branch Name
      shell: bash
      id: validate
      run: |
        if ! [[ ${{ env.PR_BRANCH }} =~ ^Release\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Branch name must follow format Release.#.#.#"
          exit 1
        fi

    - name: Detect Changed Packages
      id: filter
      uses: dorny/paths-filter@v3
      with:
        filters: |
          "A:LibraryA/LibraryA.csproj:B+C":
            - 'LibraryA/**'
          "B:LibraryB/LibraryB.csproj:C":
            - 'LibraryB/**'
          "C:LibraryC/LibraryC.csproj:":
            - 'LibraryC/**'
          "D:LibraryD/LibraryD.nuspec:B":
            - 'LibraryD/**'

    - name: Order Dependencies
      shell: bash
      id: order
      run: |
        python3 - << 'EOF'
        import json
        import sys
        import os
        from collections import defaultdict

        def create_graph(items):
            graph = defaultdict(list)
            nodes = set()
            
            # Parse the items and build the graph
            for item in items:
                parts = item.strip('"').split(':')
                key = parts[0]
                deps = parts[2].split('+') if parts[2] else []
                nodes.add(key)
                for dep in deps:
                    if dep:
                        graph[key].append(dep)
                        nodes.add(dep)
            return graph, nodes

        def topological_sort(graph, nodes):
            # Track visited nodes and detect cycles
            visited = set()
            temp = set()
            order = []
            
            def visit(node):
                if node in temp:
                    sys.exit(f"Error: Circular dependency detected involving {node}")
                if node not in visited:
                    temp.add(node)
                    for dep in graph[node]:
                        visit(dep)
                    temp.remove(node)
                    visited.add(node)
                    order.append(node)
            
            # Visit each node
            for node in nodes:
                if node not in visited:
                    visit(node)
            
            return order

        # Get the changes from GitHub Actions environment
        changes = '${{ steps.filter.outputs.changes }}'
        if changes == '[]':
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write('ordered_changes=[]')
            sys.exit(0)

        # Remove brackets and split into items
        items = [item.strip() for item in changes.strip('[]').split(',')]
        
        # Create dependency graph
        graph, nodes = create_graph(items)
        
        # Get topological order
        ordered_keys = topological_sort(graph, nodes)
        
        # Filter and reorder the original items based on the topological order
        ordered_items = []
        key_to_item = {item.strip('"').split(':')[0]: item for item in items}
        for key in ordered_keys:
            if key in key_to_item:
                ordered_items.append(key_to_item[key])
        
        # Output the ordered array using environment file
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'ordered_changes=[{",".join(ordered_items)}]')
        EOF

    - name: Get PR Comments
      id: pr_comment
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });
          const prBody = context.payload.pull_request.body || '';
          const allText = [prBody, ...comments.map(c => c.body)].join('\n');
          return allText;
        result-encoding: string

    - name: Update Versions
      shell: bash
      id: versions
      run: |
        python3 - << 'EOF'
        import xml.etree.ElementTree as ET
        import re
        import sys
        import os
        import glob

        # Register the namespace to avoid ns0 prefix
        ET.register_namespace('', 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd')

        def parse_version(version_str):
            match = re.match(r'(\d+)\.(\d+)\.(\d+)', version_str)
            if not match:
                return (0, 0, 0)
            return tuple(map(int, match.groups()))

        def get_version_from_file(file_path):
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                version_elem = tree.find(".//Version")
                return version_elem.text if version_elem is not None else "1.0.0"
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                version_elem = tree.find(".//ns:version", ns)
                return version_elem.text if version_elem is not None else "1.0.0"
            return "1.0.0"

        def update_version_in_file(file_path, new_version):
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                version_elem = tree.find(".//Version")
                if version_elem is not None:
                    version_elem.text = new_version
                tree.write(file_path, encoding='utf-8', xml_declaration=True)
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                version_elem = tree.find(".//ns:version", ns)
                if version_elem is not None:
                    version_elem.text = new_version
                # Use default namespace for writing
                tree.write(file_path, encoding='utf-8', xml_declaration=True)

        def update_dependency_version(file_path, dep_key, new_version):
            updated = False
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                # Look for PackageReference with the matching Include attribute
                for pkg_ref in tree.findall(".//PackageReference[@Include='Library{}']".format(dep_key)):
                    pkg_ref.set('Version', new_version)
                    updated = True
                if updated:
                    tree.write(file_path, encoding='utf-8', xml_declaration=True)
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                # Look for dependency with matching id
                for dep in tree.findall(".//ns:dependency[@id='Library{}']".format(dep_key), ns):
                    dep.set('version', new_version)
                    updated = True
                if updated:
                    tree.write(file_path, encoding='utf-8', xml_declaration=True)
            return updated

        def get_library_info(file_path):
            """Extract library name and its dependencies from a file."""
            deps = []
            if file_path.endswith('.csproj'):
                tree = ET.parse(file_path)
                # Get package references
                for ref in tree.findall(".//PackageReference"):
                    pkg_name = ref.get('Include', '')
                    if pkg_name.startswith('Library'):
                        deps.append(pkg_name.replace('Library', ''))
            elif file_path.endswith('.nuspec'):
                tree = ET.parse(file_path)
                ns = {'ns': 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'}
                # Get dependencies
                for dep in tree.findall(".//ns:dependency", ns):
                    dep_id = dep.get('id', '')
                    if dep_id.startswith('Library'):
                        deps.append(dep_id.replace('Library', ''))
            
            # Extract library name from path
            lib_name = os.path.basename(os.path.dirname(file_path)).replace('Library', '')
            return lib_name, deps

        def scan_all_libraries():
            """Scan workspace for all libraries and their dependencies."""
            library_info = {}
            
            # Find all .csproj and .nuspec files
            for pattern in ['*/*.csproj', '*/*.nuspec']:
                for file_path in glob.glob(pattern):
                    lib_name, deps = get_library_info(file_path)
                    if lib_name:
                        if lib_name not in library_info:
                            library_info[lib_name] = {'file_path': file_path, 'dependencies': set()}
                        library_info[lib_name]['dependencies'].update(deps)
            
            return library_info

        def calculate_new_version(current_version, key, pr_comments):
            major, minor, patch = parse_version(current_version)
            
            # Check for version change indicators in PR comments
            if f'[BREAKING_CHANGE:{key}]' in pr_comments:
                return f"{major + 1}.0.0"
            elif f'[NEW_FEATURE:{key}]' in pr_comments:
                return f"{major}.{minor + 1}.0"
            else:
                return f"{major}.{minor}.{patch + 1}"

        # Process the changes
        changes = '${{ steps.order.outputs.ordered_changes }}'
        pr_comments = '''${{ steps.pr_comment.outputs.result }}'''

        if changes == '[]':
            sys.exit(0)

        # Remove brackets and split into items
        items = [item.strip() for item in changes.strip('[]').split(',')]
        
        # First pass: Calculate all new versions for changed libraries
        version_updates = {}
        for item in items:
            parts = item.strip('"').split(':')
            key = parts[0]
            file_path = parts[1]
            
            # Get current version
            current_version = get_version_from_file(file_path)
            
            # Calculate new version
            new_version = calculate_new_version(current_version, key, pr_comments)
            
            # Store for later use
            version_updates[key] = {
                'file_path': file_path,
                'new_version': new_version,
                'current_version': current_version
            }

        # Scan all libraries in the workspace
        all_libraries = scan_all_libraries()

        # Second pass: Update versions and dependencies
        version_changes = []
        
        # First update the versions of changed libraries
        for key, info in version_updates.items():
            # Update the package's own version
            update_version_in_file(info['file_path'], info['new_version'])
            version_changes.append(f"{key}: {info['current_version']} -> {info['new_version']}")
            
            # Update this package's version in ALL libraries that depend on it
            for lib_key, lib_info in all_libraries.items():
                if key in lib_info['dependencies']:
                    if update_dependency_version(lib_info['file_path'], key, info['new_version']):
                        version_changes.append(f"{lib_key}: Updated dependency {key} to {info['new_version']}")

        # Print summary
        print("Version changes summary:")
        for change in version_changes:
            print(change)
        
        # Write output to environment file
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'version_changes={";".join(version_changes)}')
        EOF

    - name: Commit Version Updates
      if: steps.versions.outputs.version_changes != ''
      shell: bash
      run: |
        # Configure Git
        git config --local user.email "${{ env.GIT_USER_EMAIL }}"
        git config --local user.name "${{ env.GIT_USER_NAME }}"
        
        # Make sure the working directory is clean
        git clean -fd
        
        # Add and commit changes
        git add -A
        git status
        
        # Try to commit, with error handling
        if ! git commit -m "Update versions based on PR analysis [skip ci]"; then
          echo "No changes to commit or commit failed"
          exit 0
        fi
        
        # Try to push, with retries
        max_attempts=3
        attempt=1
        while [ $attempt -le $max_attempts ]; do
          echo "Push attempt $attempt of $max_attempts"
          if git push; then
            echo "Push successful"
            break
          else
            echo "Push failed, cleaning and retrying..."
            git clean -fd
            git reset --hard HEAD
            git pull --rebase
            ((attempt++))
            if [ $attempt -gt $max_attempts ]; then
              echo "Failed to push after $max_attempts attempts"
              exit 1
            fi
            sleep 5
          fi
        done

    - name: Add PR Comment
      if: steps.versions.outputs.version_changes != ''
      uses: actions/github-script@v7
      with:
        script: |
          const changes = '${{ steps.versions.outputs.version_changes }}'.split(';');
          const body = `## Version Updates\nThe following version changes have been applied:\n\n${changes.map(c => `- ${c}`).join('\n')}`;
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: body
          });

    - name: Generate GitHub App Token
      id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app_id: ${{ secrets.ACTION_TEST_APP_ID }}
        private_key: ${{ secrets.ACTION_TEST_APP_PRIVATE_KEY }}
        owner: ${{ github.repository_owner }}
        repositories: ${{ github.event.repository.name }}

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        source-url: ${{ env.GITHUB_PACKAGES_URL }}
      env:
        NUGET_AUTH_TOKEN: ${{ steps.generate-token.outputs.token }}

    - name: Configure NuGet Source
      shell: pwsh
      run: |
        Write-Host "=== Before removing sources ==="
        dotnet nuget list source
        
        # List and remove all existing GitHub sources
        $sources = dotnet nuget list source
        $sources | Where-Object { $_ -match "Github.*" } | ForEach-Object {
            $sourceName = $_.Trim()
            Write-Host "Removing source: $sourceName"
            dotnet nuget remove source $sourceName
        }
        
        Write-Host "=== After removing sources ==="
        dotnet nuget list source
        
        # Add the new source
        Write-Host "Adding new source..."
        dotnet nuget add source "${{ env.GITHUB_PACKAGES_URL }}" `
          --username "${{ github.repository_owner }}" `
          --password "${{ steps.generate-token.outputs.token }}" `
          --store-password-in-clear-text
        
        Write-Host "=== Final source configuration ==="
        dotnet nuget list source

    - name: Build and Pack NuGet Packages
      shell: bash
      run: |
        # Process ordered changes
        changes="${{ steps.order.outputs.ordered_changes }}"
        if [ "$changes" = "[]" ]; then
          echo "No libraries to build and pack"
          exit 0
        fi

        # Create nupkg directory
        mkdir -p ${{ env.OUTPUT_DIR }}

        # Remove outer brackets and quotes, and process each item in order
        echo "$changes" | sed 's/^\[\|\]$//g' | sed 's/"//g' | tr ',' '\n' | while read -r item; do
          # Trim whitespace
          item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if [ ! -z "$item" ]; then
            # Extract path
            path=$(echo "$item" | cut -d':' -f2)
            echo "Processing $path"

            if [[ $path == *.csproj ]]; then
              echo "Building and packing $path"
              dotnet build "$path" -c ${{ env.CONFIGURATION }}
              dotnet pack "$path" -c ${{ env.CONFIGURATION }} --no-build -o ${{ env.OUTPUT_DIR }}
            elif [[ $path == *.nuspec ]]; then
              echo "Building and packing $path"
              # Get directory containing .nuspec file
              dir=$(dirname "$path")
              # Build the corresponding .csproj if it exists
              if [ -f "$dir/$dir.csproj" ]; then
                dotnet build "$dir/$dir.csproj" -c ${{ env.CONFIGURATION }}
              fi
              nuget pack "$path" -OutputDirectory ${{ env.OUTPUT_DIR }}
            fi
          fi
        done

    - name: Publish NuGet Packages
      shell: pwsh
      run: |
        # Install required modules
        Install-Module -Name PSPKI -Force -SkipPublisherCheck
        
        # Generate JWT
        $now = [DateTimeOffset]::UtcNow
        $payload = @{
          iat = [int]($now.AddSeconds(-60)).ToUnixTimeSeconds()
          exp = [int]($now.AddMinutes(10)).ToUnixTimeSeconds()
          iss = "${{ env.GITHUB_APP_ID }}"
        } | ConvertTo-Json
        
        # Convert private key from base64 and create RSA object
        $privateKeyBytes = [System.Convert]::FromBase64String("${{ env.GITHUB_APP_PRIVATE_KEY }}")
        $rsa = [System.Security.Cryptography.RSA]::Create()
        $rsa.ImportFromPem([System.Text.Encoding]::UTF8.GetString($privateKeyBytes))
        
        # Create JWT header
        $header = @{
          alg = "RS256"
          typ = "JWT"
        } | ConvertTo-Json
        
        # Encode header and payload
        $encodedHeader = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($header)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
        $encodedPayload = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($payload)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
        
        # Create signature
        $dataToSign = [System.Text.Encoding]::UTF8.GetBytes("$encodedHeader.$encodedPayload")
        $signature = $rsa.SignData($dataToSign, [System.Security.Cryptography.HashAlgorithmName]::SHA256, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)
        $encodedSignature = [Convert]::ToBase64String($signature).TrimEnd('=').Replace('+', '-').Replace('/', '_')
        
        # Combine to form JWT
        $jwt = "$encodedHeader.$encodedPayload.$encodedSignature"
        
        # Get installation token using JWT
        $installToken = (Invoke-RestMethod -Uri "https://api.github.com/app/installations/${{ env.GITHUB_APP_INSTALLATION_ID }}/access_tokens" `
          -Method Post `
          -Headers @{
            "Authorization" = "Bearer $jwt"
            "Accept" = "application/vnd.github.v3+json"
          }).token
        
        Write-Host "=== Current NuGet sources ==="
        dotnet nuget list source
        
        # Publish packages
        Get-ChildItem "${{ env.OUTPUT_DIR }}/*.nupkg" | ForEach-Object {
          Write-Host "Publishing $($_.Name) to ${{ env.GITHUB_PACKAGES_URL }}"
          dotnet nuget push $_.FullName `
            --api-key $installToken `
            --source "${{ env.GITHUB_PACKAGES_URL }}" `
            --skip-duplicate `
            --no-symbols
        }
      env:
        DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER: 0

    - name: Create Git Tags
      if: steps.versions.outputs.version_changes != ''
      shell: bash
      run: |
        # Configure Git
        git config --local user.email "${{ env.GIT_USER_EMAIL }}"
        git config --local user.name "${{ env.GIT_USER_NAME }}"
        
        # Clean state before creating tags
        git clean -fd
        git reset --hard HEAD

        # Process each version change
        echo '${{ steps.versions.outputs.version_changes }}' | tr ';' '\n' | while read -r change; do
          if [[ $change =~ ^([A-Z]):[[:space:]]([0-9]+\.[0-9]+\.[0-9]+)[[:space:]]->[[:space:]]([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            library="${BASH_REMATCH[1]}"
            new_version="${BASH_REMATCH[3]}"
            tag_name="Library${library}/v${new_version}"
            
            echo "Creating tag $tag_name"
            # Try to create and push tag with retries
            max_attempts=3
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              echo "Tag push attempt $attempt of $max_attempts"
              if git tag -a "$tag_name" -m "Release Library${library} version ${new_version}" && git push origin "$tag_name"; then
                echo "Tag push successful"
                break
              else
                echo "Tag push failed, cleaning and retrying..."
                git tag -d "$tag_name" || true
                git fetch --prune --unshallow --tags
                ((attempt++))
                if [ $attempt -gt $max_attempts ]; then
                  echo "Failed to push tag after $max_attempts attempts"
                  exit 1
                fi
                sleep 5
              fi
            done
          fi
        done

    - name: Print Changed Libraries
      shell: bash
      run: |
        changes="${{ steps.order.outputs.ordered_changes }}"
        if [ "$changes" = "[]" ]; then
          echo "No libraries were changed"
        else
          # Remove outer brackets and quotes
          filtered_changes=$(echo "$changes" | sed 's/^\[\|\]$//g' | sed 's/"//g')
          
          # Process each item
          echo "$filtered_changes" | tr ',' '\n' | while read -r item; do
            # Trim leading/trailing whitespace
            item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [ ! -z "$item" ]; then
              # Extract each part using exact positions
              key=$(echo "$item" | cut -d':' -f1)
              path=$(echo "$item" | cut -d':' -f2)
              deps=$(echo "$item" | cut -d':' -f3)
              # Extract file extension without the dot
              ext=$(echo "$path" | grep -o '\.[^.]*$' | sed 's/\.//' || echo "no extension")
              # Only output if we have a valid key
              if [ ! -z "$key" ]; then
                echo "Library changed: $key (path: $path, dependencies: ${deps:-none})"
                echo "File extension: $ext"
                echo ""
              fi
            fi
          done
        fi  