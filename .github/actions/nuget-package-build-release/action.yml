name: 'NuGet Package Build and Release'
description: 'Build and release NuGet packages with dependency management'

inputs:
  projects:
    description: 'Project configurations in JSON format'
    required: true
  github_token:
    description: 'GitHub token for API access'
    required: true

outputs:
  changes:
    description: 'Array of filter names that were detected as changed'
    value: ${{ steps.filter.outputs.changes }}
  modified_packages:
    description: 'List of projects that were changed'
    value: ${{ steps.filter.outputs.modified_packages }}
  ordered_changes:
    description: 'List of projects in dependency order'
    value: ${{ steps.filter.outputs.ordered_changes }}
  has_nuspec:
    description: 'Whether any changed package uses nuspec'
    value: ${{ steps.filter.outputs.has_nuspec }}

runs:
  using: "composite"
  steps:
    - name: Debug Info
      shell: bash
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Head ref: ${{ github.head_ref }}"
        echo "Base ref: ${{ github.base_ref }}"
        echo "Ref: ${{ github.ref }}"
        echo "Action path: ${{ github.action_path }}"
        echo "Workspace: ${{ github.workspace }}"
        echo "Event path: ${{ github.event_path }}"
        if [ -f "${{ github.event_path }}" ]; then
          echo "Event file contents:"
          cat "${{ github.event_path }}"
        else
          echo "Event file not found"
        fi

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      shell: bash
      run: |
        python -m pip install --upgrade pip
        pip install requests pyyaml

    - name: List files in action directory
      shell: bash
      run: |
        echo "Contents of ${{ github.action_path }}:"
        ls -la ${{ github.action_path }}
        echo "Contents of ${{ github.action_path }}/src:"
        ls -la ${{ github.action_path }}/src || echo "src directory not found"

    - name: Filter Changes
      id: filter
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        INPUT_PROJECTS: ${{ inputs.projects }}
      run: |
        echo "Running change detection..."
        if [ -f "${{ github.action_path }}/src/detect_changes.py" ]; then
          python "${{ github.action_path }}/src/detect_changes.py"
          echo "Change detection completed. Checking outputs..."
          if [ -f "$GITHUB_OUTPUT" ]; then
            echo "Contents of GITHUB_OUTPUT:"
            cat "$GITHUB_OUTPUT"
          else
            echo "Warning: GITHUB_OUTPUT file not found"
          fi
        else
          echo "Error: detect_changes.py not found at ${{ github.action_path }}/src/detect_changes.py"
          exit 1
        fi

    - name: Generate Configuration
      id: config
      shell: python
      env:
        INPUT_PROJECTS: ${{ inputs.projects }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        import json
        import os
        import sys
        from pathlib import Path

        print("Debug: Starting configuration generation")
        
        def process_projects(projects_json):
            print(f"Debug: Processing projects JSON: {projects_json[:100]}...")
            projects = json.loads(projects_json)
            
            # Create package mapping
            package_map = {}
            filters = {}
            
            for idx, (project_id, config) in enumerate(projects.items(), 1):
                key = f"X{idx}"
                path = config['path']
                patterns = config.get('patterns', [f"{project_id}/**"])
                deps = config.get('dependencies', [])
                
                # Create package map entry
                package_map[key] = f"{project_id}:{path}:{'+'.join(deps)}"
                
                # Create filter entry
                filters[key] = patterns
                
                print(f"Debug: Processed project {project_id} with key {key}")
            
            return package_map, filters

        def main():
            try:
                # Get input from environment variable
                projects_json = os.environ['INPUT_PROJECTS']
                print("Debug: Retrieved INPUT_PROJECTS from environment")
                
                # Process projects
                package_map, filters = process_projects(projects_json)
                print("Debug: Projects processed successfully")
                
                # Ensure scripts directory exists
                Path('scripts').mkdir(exist_ok=True)
                print("Debug: Created scripts directory")
                
                # Write package map
                with open('scripts/package_map.json', 'w') as f:
                    json.dump(package_map, f, indent=2)
                print("Debug: Wrote package_map.json")
                
                # Generate filters YAML
                with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                    f.write("filters=")
                    yaml_content = "filters: |\n"
                    for key, patterns in filters.items():
                        yaml_content += f"  {key}:\n"
                        for pattern in patterns:
                            yaml_content += f"    - '{pattern}'\n"
                    f.write(yaml_content + "\n")
                print("Debug: Wrote filters to GITHUB_OUTPUT")
                
            except Exception as e:
                print(f"Error in configuration generation: {str(e)}")
                raise

        if __name__ == '__main__':
            main()

    - name: Order Dependencies
      id: order
      shell: bash
      run: |
        python3 - << 'EOF'
        import json
        import sys
        import os
        from collections import defaultdict

        def load_package_map():
            with open('scripts/package_map.json', 'r') as f:
                return json.load(f)

        def create_graph(items, package_map):
            graph = defaultdict(list)
            nodes = set()
            
            # Create reverse mapping from library id to key
            lib_to_key = {}
            for key, value in package_map.items():
                lib_id = value.split(':')[0]
                lib_to_key[lib_id] = key
            
            # Parse the items and build the graph
            for item in items:
                key = item.strip('"')
                if key in package_map:
                    parts = package_map[key].split(':')
                    deps = parts[2].split('+') if parts[2] else []
                    nodes.add(key)
                    for dep in deps:
                        if dep and dep in lib_to_key:
                            dep_key = lib_to_key[dep]
                            if dep_key in package_map:
                                graph[key].append(dep_key)
                                nodes.add(dep_key)
            return graph, nodes

        def topological_sort(graph, nodes):
            visited = set()
            temp = set()
            order = []
            
            def visit(node):
                if node in temp:
                    sys.exit(f"Error: Circular dependency detected involving {node}")
                if node not in visited:
                    temp.add(node)
                    for dep in graph[node]:
                        visit(dep)
                    temp.remove(node)
                    visited.add(node)
                    order.append(node)
            
            for node in nodes:
                if node not in visited:
                    visit(node)
            
            return order

        # Load package mapping
        package_map = load_package_map()

        # Get the changes from GitHub Actions environment
        changes = '${{ steps.filter.outputs.changes }}'
        if changes == '[]':
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write('ordered_changes=[]\n')
                f.write('modified_packages=[]\n')
                f.write('has_nuspec=false\n')
            sys.exit(0)

        # Remove brackets and split into items
        modified_packages = [item.strip().strip('"') for item in changes.strip('[]').split(',')]
        
        # Create dependency graph
        graph, nodes = create_graph(modified_packages, package_map)
        
        # Get topological order
        ordered_keys = topological_sort(graph, nodes)
        
        # Check if any of the MODIFIED packages contain .nuspec
        has_nuspec = any('.nuspec' in package_map[key] for key in modified_packages if key in package_map)
        
        # Output the results
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'ordered_changes=[{",".join(ordered_keys)}]\n')
            f.write(f'modified_packages=[{",".join(modified_packages)}]\n')
            f.write(f'has_nuspec={str(has_nuspec).lower()}\n')

        # Write debug info to a file for the next step
        with open('scripts/dependency_debug.json', 'w') as f:
            debug_info = {
                'package_map': package_map,
                'modified_packages': modified_packages,
                'dependency_graph': {k: v for k, v in graph.items()},
                'ordered_keys': ordered_keys
            }
            json.dump(debug_info, f, indent=2)
        EOF

    - name: Debug Step Outputs
      shell: bash
      run: |
        echo "=== Debug Step Outputs ==="
        echo "Filter Changes Output:"
        echo "changes: ${{ steps.filter.outputs.changes }}"
        
        echo -e "\nConfiguration Output:"
        if [ -f "scripts/package_map.json" ]; then
          echo "package_map.json contents:"
          cat scripts/package_map.json
        else
          echo "package_map.json not found"
        fi
        
        echo -e "\nOrder Dependencies Output:"
        echo "ordered_changes: ${{ steps.order.outputs.ordered_changes }}"
        echo "modified_packages: ${{ steps.order.outputs.modified_packages }}"
        echo "has_nuspec: ${{ steps.order.outputs.has_nuspec }}"

    - name: Debug Dependencies
      shell: bash
      run: |
        echo "=== Dependency Debug Information ==="
        echo "Reading debug info from scripts/dependency_debug.json..."
        
        python3 - << 'EOF'
        import json
        import sys
        
        try:
            with open('scripts/dependency_debug.json', 'r') as f:
                debug_info = json.load(f)
            
            package_map = debug_info['package_map']
            modified_packages = debug_info['modified_packages']
            dependency_graph = debug_info['dependency_graph']
            ordered_keys = debug_info['ordered_keys']
            
            # Create reverse mapping for better readability
            key_to_project = {}
            for key, value in package_map.items():
                project_id = value.split(':')[0]
                key_to_project[key] = project_id
            
            print("\nModified Packages:")
            print("=================")
            for pkg in modified_packages:
                if pkg in package_map:
                    project_info = package_map[pkg].split(':')
                    print(f"- {pkg} ({key_to_project[pkg]}):")
                    print(f"  Path: {project_info[1]}")
                    if project_info[2]:
                        print(f"  Dependencies: {project_info[2].replace('+', ', ')}")
                    else:
                        print("  Dependencies: None")
            
            print("\nDependency Graph:")
            print("================")
            for key in dependency_graph:
                deps = dependency_graph[key]
                if deps:
                    print(f"- {key_to_project[key]} depends on:")
                    for dep in deps:
                        print(f"  - {key_to_project[dep]}")
                else:
                    print(f"- {key_to_project[key]} has no dependencies")
            
            print("\nBuild Order:")
            print("===========")
            for i, key in enumerate(ordered_keys, 1):
                print(f"{i}. {key_to_project[key]}")
            
        except Exception as e:
            print(f"Error reading debug info: {str(e)}")
            sys.exit(1)
        EOF 